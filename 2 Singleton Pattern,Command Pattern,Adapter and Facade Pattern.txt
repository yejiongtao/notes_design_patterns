1. Singleton Pattern
	ensures a class has only one instance, and provides a global point of access to it.
	in English
		static, so that the whole app shares the same one 
		always checking if it already exists before creating
		forbide clone()
	example
		public class SingletonObject
		{
			private static SingletonObject ref;

			private SingletonObject()
			{
				// some coded
			}

			public static synchronized SingletonObject getSingletonObject()		// note the synchronized
			{
				if (ref == null)
					// it's ok, we can call this constructor
					ref = new SingletonObject();		
				return ref;
			}

			public Object clone() throws CloneNotSupportedException
			{
				throw new CloneNotSupportedException(); 
				// that'll teach 'em
			}
		}
	synchronization is expensive
		and is only needed when ref==null, so if you really care about the overhead
			private static SingletoneObject ref = new SingletonObject();
			public static SingletonObject getSingletonObject(){
				return ref;
			}
		or
			private volatile static SingletonObject ref;	// note the volatile here!
				// means the value of this variable will never be cached thread-locally: all reads and writes will go straight to "main memory"
			public static SingletonObject getSingletonObject(){
				if(ref == null)
					synchronized(SingletonObject.class)
						if(ref == null)		// don't forget to check again
							ref = new SingletonObject();
				return ref;
			}

2. Command Pattern
	encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations
	it's pretty straight forward
		create an abstract class to represent a command, containing a execute() method
		extend it to implement concrete commands
		delegate the commands to certain invokers
		the invokers call the execute() appropriately
	you can queue the commands and delegate to threads
		in this way, a certain thread can perform different commands
	besides execute(), a command can have undo(), store(), and load()
		store() is to save the logging
		and load() is to load the logging and redo the command when system error occurs

3. Adapter and Facade Pattern

